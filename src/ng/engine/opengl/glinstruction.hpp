#ifndef NG_GLINSTRUCTION_HPP
#define NG_GLINSTRUCTION_HPP

#include <cstdint>
#include <vector>
#include <memory>
#include <future>

#include <GL/gl.h>

namespace ng
{

struct OpenGLInstruction
{
    using OpCodeType = std::uint32_t;
    using ParamType = std::uintptr_t;

    static const std::size_t MaxParams = 16;

    OpCodeType OpCode;
    std::size_t NumParams;
    ParamType Params[1]; // note: flexible array sized by NumParams

    std::size_t GetByteSize() const
    {
        return GetSizeForNumParams(NumParams);
    }

    static std::size_t GetMaxByteSize()
    {
        return GetSizeForNumParams(MaxParams);
    }

    static constexpr std::size_t GetSizeForNumParams(std::size_t params)
    {
        return sizeof(OpenGLInstruction) + (params - 1) * sizeof(Params[0]);
    }
};

static_assert(std::is_pod<OpenGLInstruction>::value, "GPUInstructions must be plain old data.");

class OpenGLInstructionLinearBuffer
{
    std::vector<char> mBuffer;
    std::size_t mReadHead;
    std::size_t mWriteHead;

public:
    OpenGLInstructionLinearBuffer(std::size_t commandBufferSize);

    // Returns true on success, false on failure.
    // On failure, the instruction is not pushed. Failure happens due to not enough memory.
    // Failure can be handled either by increasing commandBufferSize, or by flushing the instructions.
    bool PushInstruction(const OpenGLInstruction& inst);

    // Checks if there is an instruction available to read.
    bool CanPopInstruction() const;

    // returns true and writes to inst if there was something to pop that was popped.
    // returns false otherwise.
    // Warning: make sure you're writing to an instruction allocated with enough room!
    //          recommend allocating a SizedOpenGLInstruction<OpenGLInstruction::MaxParams>
    // nice pattern: while (PopInstruction(inst))
    bool PopInstruction(OpenGLInstruction& inst);

    // Resets the linear buffer back to the start.
    void Reset();
};

class OpenGLInstructionRingBuffer
{
    std::vector<char> mBuffer;
    std::size_t mReadHead;
    std::size_t mWriteHead;

public:
    OpenGLInstructionRingBuffer(std::size_t instructionBufferSize);

    // Returns true on success, false on failure.
    // On failure, the instruction is not pushed. Failure happens due to not enough memory.
    // Failure can be handled either by increasing commandBufferSize, or by flushing the instructions.
    bool PushInstruction(const OpenGLInstruction& inst);

    // returns true if there is an instruction available to read
    bool CanPopInstruction() const;

    // returns true and writes to inst if there was something to pop that was popped.
    // returns false otherwise.
    // Warning: make sure you're writing to an instruction allocated with enough room!
    //          recommend allocating a SizedOpenGLInstruction<OpenGLInstruction::MaxParams>
    // nice pattern: while (PopInstruction(inst))
    bool PopInstruction(OpenGLInstruction& inst);
};

enum class OpenGLOpCode : OpenGLInstruction::OpCodeType
{
    Clear,
    // params:
    //         0) GLbitfield mask
    // notes:
    //         * acts as glClear.
    GenBuffer,
    // params:
    //         0) std::promise<OpenGLBufferHandle>* bufferPromise
    // notes:
    //         * the promised OpenGLBufferHandle will be created by glGenBuffers.
    //         * will release ownership of bufferPromise (ie. delete bufferPromise.)
    DeleteBuffer,
    // params:
    //         0) GLuint buffer
    // notes:
    //         * buffer must be a buffer ID generated by glGenBuffers (or 0.)
    //         * buffer will be deleted with glDeleteBuffers.
    BufferData,
    // params:
    //         0) std::shared_future<OpenGLBufferHandle>* bufferHandle
    //         1) GLenum target
    //         2) GLsizeiptr size
    //         3) std::shared_ptr<const void>* dataHandle
    //         4) GLenum usage
    // notes:
    //         * will allocate and fill the buffer with data by binding it to target.
    //         * dataHandle may be pointing to nullptr, which will leave the buffer uninitialized.
    //         * will release ownership of dataHandle (ie. delete dataHandle.)
    //         * will release ownership of bufferHandle (ie. delete bufferHandle.)
    GenShader,
    // params:
    //         0) std::promise<OpenGLShaderHandle>* shaderPromise
    // notes:
    //         * the promised OpenGLShaderHandle will be created by glCreateShader.
    //         * will release ownership of the shaderPromise (ie. delete shaderPromise.)
    DeleteShader,
    // params:
    //         0) GLuint shader
    // notes:
    //         * shader must be a shader ID generated by glCreateShader (or 0.)
    //         * shader will be deleted with glDeleteShader.
    CompileShader,
    // params:
    //         0) std::shared_future<OpenGLShaderHandle>* shaderHandle
    //         1) std::shared_ptr<const char>* sourceHandle
    // notes:
    //         * compiles the source in sourceHandle into shaderHandle.
    //         * will release ownership of the sourceHandle (ie. delete sourceHandle.)
    //         * will release ownership of the shaderHandle (ie. delete shaderHandle.)
    ShaderStatus,
    // params:
    //         0) std::promise<std::pair<bool,std::string>>* statusPromise
    //         1) std::shared_future<OpenGLShaderHandle>* shaderHandle
    // notes:
    //         * gets the status of the shader and stores it in the promise.
    //         * will release ownership of the shaderHandle (ie. delete shaderHandle.)
    //         * will release ownership of the statusPromise (ie. delete statusPromise.)
    GenShaderProgram,
    // params:
    //         0) std::promise<OpenGLShaderProgramHandle>* shaderProgramPromise
    // notes:
    //         * the promised OpenGLShaderProgramHandle will be created by glCreateProgram.
    //         * will release ownership of the shaderProgramPromise (ie. delete shaderProgramPromise.)
    DeleteShaderProgram,
    // params:
    //         0) GLuint program
    // notes:
    //         * program must be a program ID generated by glCreateProgram (or 0.)
    //         * program will be deleted with glDeleteProgram.
    LinkShaderProgram,
    // params:
    //         0) std::shared_future<OpenGLShaderProgramHandle>* shaderProgramHandle
    //         1) std::shared_future<OpenGLShaderHandle>* vertexShaderHandle
    //         2) std::shared_future<OpenGLShaderHandle>* fragmentShaderHandle
    // notes:
    //         * will attach and link the vertex and fragment shaders to the program.
    //         * will release ownership of fragmentShaderHandle (ie. delete fragmentShaderHandle)
    //         * will release ownership of vertexShaderHandle (ie. delete vertexShaderHandle)
    //         * will release ownership of shaderProgramHandle (ie. delete shaderProgramHandle)
    ShaderProgramStatus,
    // params:
    //         0) std::promise<std::pair<bool,std::string>>* statusPromise
    //         1) std::shared_future<OpenGLShaderProgramHandle>* shaderProgramHandle
    // notes:
    //         * gets the status of the shader and stores it in the promise.
    //         * will release ownership of the shaderProgramHandle (ie. delete shaderProgramHandle.)
    //         * will release ownership of the statusPromise (ie. delete statusPromise.)
    DrawVertexArray,
    //         0) VertexArray* vertexArray
    //         1) std::shared_future<OpenGLShaderProgramHandle>* programHandle
    //         2) GLenum mode
    //         3) GLint firstVertexIndex
    //         4) GLsizei vertexCount
    // notes:
    //         * will render the vertexArray using the program.
    //         * will release ownership of program (ie. delete program.)
    //         * will release ownership of vertexArray (ie. delete vertexArray.)
    SwapBuffers,
    // params:
    //         none.
    // notes:
    //         * special instruction to signal a swap of buffers to the window.
    Quit
    // params:
    //         none.
    // notes:
    //         * special instruction to exit the graphics thread.
};

static constexpr const char* OpenGLOpCodeToString(OpenGLOpCode code)
{
    return code == OpenGLOpCode::Clear ? "Clear"
         : code == OpenGLOpCode::GenBuffer ? "GenBuffer"
         : code == OpenGLOpCode::DeleteBuffer ? "DeleteBuffer"
         : code == OpenGLOpCode::BufferData ? "BufferData"
         : code == OpenGLOpCode::GenShader ? "GenShader"
         : code == OpenGLOpCode::DeleteShader ? "DeleteShader"
         : code == OpenGLOpCode::CompileShader ? "CompileShader"
         : code == OpenGLOpCode::ShaderStatus ? "ShaderStatus"
         : code == OpenGLOpCode::GenShaderProgram ? "GenShaderProgram"
         : code == OpenGLOpCode::DeleteShaderProgram ? "DeleteShaderProgram"
         : code == OpenGLOpCode::LinkShaderProgram ? "LinkShaderProgram"
         : code == OpenGLOpCode::ShaderProgramStatus ? "ShaderProgramStatus"
         : code == OpenGLOpCode::DrawVertexArray ? "DrawVertexArray"
         : code == OpenGLOpCode::SwapBuffers ? "SwapBuffers"
         : code == OpenGLOpCode::Quit ? "Quit"
         : throw std::logic_error("No such OpenGLOpCode");
}

template<std::size_t NParams>
struct SizedOpenGLInstruction
{
    static_assert(NParams <= OpenGLInstruction::MaxParams, "Limit of OpenGL instruction parameters should be respected.");

    struct NoInitTag { };

    union
    {
        char InstructionData[OpenGLInstruction::GetSizeForNumParams(NParams)];
        OpenGLInstruction Instruction;
    };

    SizedOpenGLInstruction(NoInitTag){ }

    SizedOpenGLInstruction(OpenGLOpCode code)
    {
        Instruction.NumParams = NParams;
        Instruction.OpCode = static_cast<OpenGLInstruction::OpCodeType>(code);
    }
};

class VertexArray;
class OpenGLBufferHandle;
class OpenGLShaderHandle;
class OpenGLShaderProgramHandle;

template<class HandleType, OpenGLOpCode OpCode>
struct GenResourceOpCodeParams
{
    std::unique_ptr<std::promise<HandleType>> Promise;

    bool AutoCleanup;

    GenResourceOpCodeParams(std::unique_ptr<std::promise<HandleType>> promise, bool autoCleanup)
        : Promise(std::move(promise))
        , AutoCleanup(AutoCleanup)
    { }

    GenResourceOpCodeParams(const OpenGLInstruction& inst, bool autoCleanup)
        : Promise(reinterpret_cast<std::promise<HandleType>*>(inst.Params[0]))
        , AutoCleanup(autoCleanup)
    { }

    ~GenResourceOpCodeParams()
    {
        if (!AutoCleanup)
        {
            Promise.release();
        }
    }

    SizedOpenGLInstruction<1> ToInstruction() const
    {
        SizedOpenGLInstruction<1> si(OpCode);
        si.Instruction.Params[0] = reinterpret_cast<std::uintptr_t>(Promise.get());
        return si;
    }
};

template<class HandleType, OpenGLOpCode OpCode>
struct StatusOpCodeParams
{
    std::unique_ptr<std::promise<std::pair<bool,std::string>>> Promise;
    std::unique_ptr<std::shared_future<HandleType>> Handle;

    bool AutoCleanup;

    StatusOpCodeParams(std::unique_ptr<std::promise<std::pair<bool,std::string>>> promise,
                       std::unique_ptr<std::shared_future<HandleType>> handle,
                       bool autoCleanup)
        : Promise(std::move(promise))
        , Handle(std::move(handle))
        , AutoCleanup(autoCleanup)
    { }

    StatusOpCodeParams(const OpenGLInstruction& inst, bool autoCleanup)
        : Promise(reinterpret_cast<std::promise<std::pair<bool,std::string>>*>(inst.Params[0]))
        , Handle(reinterpret_cast<std::shared_ptr<HandleType>*>(inst.Params[1]))
        , AutoCleanup(autoCleanup)
    { }

    ~StatusOpCodeParams()
    {
        if (!AutoCleanup)
        {
            Handle.release();
            Promise.release();
        }
    }

    SizedOpenGLInstruction<2> ToInstruction() const
    {
        SizedOpenGLInstruction<2> si(OpCode);
        si.Instruction.Params[0] = reinterpret_cast<std::uintptr_t>(Promise.get());
        si.Instruction.Params[1] = reinterpret_cast<std::uintptr_t>(Handle.get());
        return si;
    }
};

template<OpenGLOpCode OpCode>
struct DeleteResourceOpCodeParams
{
    GLuint Handle;

    DeleteResourceOpCodeParams(GLuint handle)
        : Handle(handle)
    { }

    DeleteResourceOpCodeParams(const OpenGLInstruction &inst)
        : Handle(inst.Params[0])
    { }

    SizedOpenGLInstruction<1> ToInstruction() const
    {
        SizedOpenGLInstruction<1> si(OpCode);
        si.Instruction.Params[0] = Handle;
        return si;
    }
};

struct ClearOpCodeParams
{
    GLbitfield Mask;

    ClearOpCodeParams(GLbitfield mask);
    ClearOpCodeParams(const OpenGLInstruction& inst);

    SizedOpenGLInstruction<1> ToInstruction() const;
};

using GenBufferOpCodeParams = GenResourceOpCodeParams<OpenGLBufferHandle, OpenGLOpCode::GenBuffer>;
using DeleteBufferOpCodeParams = DeleteResourceOpCodeParams<OpenGLOpCode::DeleteBuffer>;

struct BufferDataOpCodeParams
{
    std::unique_ptr<std::shared_future<OpenGLBufferHandle>> BufferHandle;
    GLenum Target;
    GLsizeiptr Size;
    std::unique_ptr<std::shared_ptr<const void>> DataHandle;
    GLenum Usage;

    bool AutoCleanup;

    BufferDataOpCodeParams(
            std::unique_ptr<std::shared_future<OpenGLBufferHandle>> bufferHandle,
            GLenum target,
            GLsizeiptr size,
            std::unique_ptr<std::shared_ptr<const void>> dataHandle,
            GLenum usage,
            bool autoCleanup);

    BufferDataOpCodeParams(const OpenGLInstruction& inst, bool autoCleanup);

    ~BufferDataOpCodeParams();

    SizedOpenGLInstruction<5> ToInstruction() const;
};

using GenShaderOpCodeParams = GenResourceOpCodeParams<OpenGLShaderHandle, OpenGLOpCode::GenShader>;
using DeleteShaderOpCodeParams = DeleteResourceOpCodeParams<OpenGLOpCode::DeleteShader>;

struct CompileShaderOpCodeParams
{
    std::unique_ptr<std::shared_future<OpenGLShaderHandle>> ShaderHandle;
    std::unique_ptr<std::shared_ptr<const char>> SourceHandle;

    bool AutoCleanup;

    CompileShaderOpCodeParams(
            std::unique_ptr<std::shared_future<OpenGLShaderHandle>> shaderHandle,
            std::unique_ptr<std::shared_ptr<const char>> sourceHandle,
            bool autoCleanup);

    CompileShaderOpCodeParams(const OpenGLInstruction& inst, bool autoCleanup);

    ~CompileShaderOpCodeParams();

    SizedOpenGLInstruction<2> ToInstruction() const;
};

using ShaderStatusOpCodeParams = StatusOpCodeParams<OpenGLShaderHandle, OpenGLOpCode::ShaderStatus>;

using GenShaderProgramOpCodeParams = GenResourceOpCodeParams<OpenGLShaderProgramHandle, OpenGLOpCode::GenShaderProgram>;
using DeleteShaderProgramOpCodeParams = DeleteResourceOpCodeParams<OpenGLOpCode::DeleteShaderProgram>;

struct LinkShaderProgramOpCodeParams
{
    std::unique_ptr<std::shared_future<OpenGLShaderProgramHandle>> ShaderProgramHandle;
    std::unique_ptr<std::shared_future<OpenGLShaderHandle>> VertexShaderHandle;
    std::unique_ptr<std::shared_future<OpenGLShaderHandle>> FragmentShaderHandle;

    bool AutoCleanup;

    LinkShaderProgramOpCodeParams(
            std::unique_ptr<std::shared_future<OpenGLShaderProgramHandle>> shaderProgramHandle,
            std::unique_ptr<std::shared_future<OpenGLShaderHandle>> vertexShaderHandle,
            std::unique_ptr<std::shared_future<OpenGLShaderHandle>> fragmentShaderHandle,
            bool autoCleanup);

    LinkShaderProgramOpCodeParams(const OpenGLInstruction& inst, bool autoCleanup);

    ~LinkShaderProgramOpCodeParams();

    SizedOpenGLInstruction<3> ToInstruction() const;
};

using ShaderProgramStatusOpCodeParams = StatusOpCodeParams<OpenGLShaderProgramHandle, OpenGLOpCode::ShaderProgramStatus>;

struct DrawVertexArrayOpCodeParams
{
    std::unique_ptr<VertexArray> VertexArrayHandle;
    std::unique_ptr<std::shared_future<OpenGLShaderProgramHandle>> ProgramHandle;
    GLenum Mode;
    GLint FirstVertexIndex;
    GLsizei VertexCount;

    bool AutoCleanup;

    DrawVertexArrayOpCodeParams(
            std::unique_ptr<VertexArray> vertexArrayHandle,
            std::unique_ptr<std::shared_future<OpenGLShaderProgramHandle>> programHandle,
            GLenum mode,
            GLint firstVertexIndex,
            GLsizei vertexCount,
            bool autoCleanup);

    DrawVertexArrayOpCodeParams(const OpenGLInstruction& inst, bool autoCleanup);

    ~DrawVertexArrayOpCodeParams();

    SizedOpenGLInstruction<5> ToInstruction() const;
};

struct SwapBuffersOpCodeParams
{
    SwapBuffersOpCodeParams();

    SizedOpenGLInstruction<0> ToInstruction() const;
};

struct QuitOpCodeParams
{
    QuitOpCodeParams();

    SizedOpenGLInstruction<0> ToInstruction() const;
};

} // end namespace ng

#endif // NG_GLINSTRUCTION_HPP
